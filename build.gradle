plugins {
  id 'com.github.johnrengelman.shadow' version '8.1.1'
  id 'java'
}


// Skip old/unfinished projects in gradle build. these are still included in eclipse
def excludes = ['communication', 'nfproperties']

['clean', 'compileJava', 'assemble', 'build', 'test', 'check', 'wrapper', 'sonarcube'].each { mytask ->
	if(tasks.names.contains(mytask)) {
		//println "Configuring task '"+mytask+"'"
		tasks.named(mytask) {
			gradle.includedBuilds.each { build ->
				if(!excludes.contains(build.name)) {
					dependsOn build.task(':'+mytask)
				}
			}
		}
	}
	else {
		//println "Creating task '"+mytask+"'"
		project.tasks.create([name: mytask]) {	
			gradle.includedBuilds.each { build ->
				if(!excludes.contains(build.name)) {
					dependsOn build.task(':'+mytask)
				}
			}
		}
	}
}

task createZip(type: Zip) {
    archiveFileName = 'jadex-v.zip'
    destinationDirectory = file('deploy')
    includeEmptyDirs = false
    
    from(sourceSets.main.output) {
        gradle.includedBuilds.each { build ->
            from("${build.projectDir}/build/libs") {
                include '**/*.jar'
                into 'lib' // Zielverzeichnis fÃ¼r JAR-Dateien festlegen
                eachFile { f -> f.path = "lib/${f.name}" }
                duplicatesStrategy = DuplicatesStrategy.EXCLUDE
            }
        }
    }

    //def classpath = gradle.includedBuilds.collect { build -> build.projectDir.path + "/build/libs/*.jar" }.join(':')
    def scriptContent = "#!/bin/bash\njava -cp \"lib/*\" jadex.micro.helloworld.HelloWorldAgent"
    def scriptFile = file('startHelloWorld.sh')
    scriptFile.text = scriptContent
    scriptFile.setExecutable(true)
    
    into('') {
        from scriptFile
    }
}


/*def hasSources(build) {
    return file("${build.projectDir}/src").exists()
}

gradle.includedBuilds.each { build ->
    if (hasSources(build)) {
        tasks.register("copyDeps_${build.name}", Copy) {
        	println "register $build.name"
            doLast {
                println "in copy"
                copy {
                    from configurations.implementation
                    into 'build/deps'
                }
            }
        }
        ['build'].each { taskName ->
            tasks.named(taskName) { dependsOn "copyDeps_${build.name}" }
        }
    }
}*/