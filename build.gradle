// For deployment on server
// ORG_GRADLE_PROJECT_dl_host - download host
// ORG_GRADLE_PROJECT_tag_url - git repo

// ORG_GRADLE_PROJECT_repoactoron - nexus

// Maven central needs
// ORG_GRADLE_PROJECT_repocentral
// ORG_GRADLE_PROJECT_sigKey
// ORG_GRADLE_PROJECT_signingPassword

buildscript {
	repositories {
    	mavenCentral()
  	}	
	dependencies {
		classpath 'com.hierynomus:sshj:0.38.0'
  	}
}

plugins {
    id 'java-library'
}

description = 'Jadex root project'

group = 'jadex'

if(System.getProperty("PUBLISH_SCRIPT_PATH"))
	apply from: System.getProperty("PUBLISH_SCRIPT_PATH")

// Skip old/unfinished projects in gradle build. these are still included in eclipse
def excludes = ['communication', 'nfproperties']

['clean', 'compileJava', 'assemble', 'build', 'test', 'check', 'wrapper', 'sonarcube', 'publish', 'javadoc'].each { mytask ->
	if(tasks.names.contains(mytask)) {
		println "Configuring task '"+mytask+"'"
		tasks.named(mytask) {
			gradle.includedBuilds.each { build ->
				//println "build name: "+build.getName()+" "+rootProject.name
				if(!rootProject.name.equals(build.getName())) {
					if(!excludes.contains(build.name)) {
						def taskInBuild = build.task(':'+mytask) // one cannot check if a task exists in a build :-(
						//if(taskInBuild)
						dependsOn taskInBuild
						println "cot: "+build.getName()+" "+mytask
					}
				}
				else
				{
					//println "skipping: "+build.getName()
				}
			}
		}
	}
	else {
		println "Creating task '"+mytask+"'"
		project.tasks.create([name: mytask]) {	
			gradle.includedBuilds.each { build ->
				//println "build name: "+build.getName()+" "+rootProject.name
				if(!rootProject.name.equals(build.getName())) {
					if(!excludes.contains(build.name)) {
						def taskInBuild = build.task(':'+mytask)
						//if(taskInBuild)
						dependsOn build.task(':'+mytask)
						println "crt: "+build.getName()+" "+mytask
					}
				}
				else
				{
					//println "skipping: "+build.getName()
				}
			}
		}
	}
}

task closeStagingRepo {
    group = "publishing"

    doLast {
        def stagedRepositoryId = System.getProperty("repoId")
        if(stagedRepositoryId==null) {
        	println "no staging repo id: "+stagedRepositoryId
        }
        else
        {
	        def url = new URL("https://oss.sonatype.org/service/local/staging/profiles/5bcba2b9075ec8/finish")
	        def connection = url.openConnection() as HttpURLConnection
	        connection.setRequestMethod("POST")
	        connection.setDoOutput(true)
	        connection.setRequestProperty("Content-Type", "application/xml")
	        def user = System.getProperty("centralUser")
	        def pass = System.getProperty("centralPassword")
    		connection.setRequestProperty("Authorization", "Basic " + Base64.getEncoder().encodeToString((user+":"+pass).getBytes()))
	
	        def requestBody = """
	            <promoteRequest>
	                <data>
	                    <stagedRepositoryId>${stagedRepositoryId}</stagedRepositoryId>
	                    <description>Jadex</description>
	                </data>
	            </promoteRequest>
	        """
	
	        try (OutputStream os = connection.outputStream) {
	            byte[] input = requestBody.getBytes("utf-8")
	            os.write(input, 0, input.length)
	        }
	
			def responseCode = connection.getResponseCode()
			println "Response Code: ${responseCode}"
    		
	        if (responseCode == 201) {
	            def response = new StringBuffer()
	            try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.inputStream))) {
	                String line
	                while ((line = in.readLine()) != null) {
	                    response.append(line)
	                }
	            }
	            println "Response: ${response.toString()}"
	        } else {
	            println "POST request failed"
	        }
	
	        connection.disconnect()
		}
    }
}
closeStagingRepo.mustRunAfter publish

task releaseStagingRepo {
    group = "publishing"

    doLast {
        publishing.repositories.maven.release()
    }
}
releaseStagingRepo.mustRunAfter closeStagingRepo

def createEmptyDirOnSSH(net.schmizz.sshj.SSHClient ssh, String dir) {
	def session = ssh.startSession();
	def cmd = session.exec("ls " + dir);
	waitForSSHCmd(cmd);
	cmd.close();
	
	if (cmd.getExitStatus() == 0) {
		// Old deployment exist, remove...
		session = ssh.startSession();
		cmd = session.exec("rm -rf " + dir);
		waitForSSHCmd(cmd);
		cmd.close();
	}
	
	session = ssh.startSession();
	cmd = session.exec("mkdir " + dir);
	waitForSSHCmd(cmd);
	cmd.close();
}

def waitForSSHCmd(cmd) {
	// BufferedReader reader = new BufferedReader(new InputStreamReader(cmd.getInputStream()));
	// reader.lines().collect(java.util.stream.Collectors.joining("\n"));
	def is = cmd.getInputStream();
	def data = new byte[4096];
	int cnt;
	while((cnt = is.read(data, 0, data.length))!=-1) {
		//System.out.write(data, 0, cnt);
		//System.out.flush();
	}
}

task createZip(type: Zip) {
	def jv = System.getProperty("JADEX_VERSION");
	println "Jadex Build Version " + jv

    archiveFileName = 'jadex-v'+jv+'.zip'
    destinationDirectory = file('deploy')
    includeEmptyDirs = false
    
    from(sourceSets.main.output) {
        gradle.includedBuilds.each { build ->
            from("${build.projectDir}/build/libs") {
                include '**/*.jar'
                into 'lib' 
                eachFile { f -> f.path = "lib/${f.name}" }
                duplicatesStrategy = DuplicatesStrategy.EXCLUDE
            }
        }
    }

    //def classpath = gradle.includedBuilds.collect { build -> build.projectDir.path + "/build/libs/*.jar" }.join(':')
    def scriptContent = '#!/bin/bash\njava -cp "lib/*" jadex.micro.helloworld.HelloWorldAgent'
    def scriptFile = file('startHelloWorld.sh')
    scriptFile.text = scriptContent
    scriptFile.setExecutable(true)
    
    into('') {
        from scriptFile
    }
}

task deployZip() {
	dependsOn createZip
	doLast {
		//if(!gradle.ext.productionmode)
		//	throw new IllegalStateException("Can only deploy zips in production mode.");
		
		if(getVar('dl_host', project)==null)
			throw new RuntimeException("Deploy requires deployment variables set: dl_host, tag_url");
		
		def acc = getDownloadServerAccess();
		
		def dir = "/www/releases/" + project.ext.jadex_build_version;
		//def zipsdir = "" + project.buildDir + File.separator + 'distributions' + File.separator + 'zips';
		def zipsdir = file('deploy').path;

		net.schmizz.sshj.SSHClient ssh = new net.schmizz.sshj.SSHClient();
		ssh.addHostKeyVerifier(acc.fingerprint);
		ssh.connect(acc.host, acc.port);
		try {
			ssh.authPassword(acc.user, acc.password);
			
			createEmptyDirOnSSH(ssh, dir);
			
			def children = new net.schmizz.sshj.xfer.FileSystemFile(zipsdir).getChildren();
			for (def child : children) {
				ssh.newSCPFileTransfer().upload(child, dir + "/");
			}
        } catch (Exception e) {
        	throw new RuntimeException(e); 
        } finally {
            ssh.disconnect();
        }
        
		println "Zip deployed.";
	}
}

def getDownloadServerAccess() {
	def downloadserver_url = getVar('dl_host', project)
    return parseURLWithCredentials(downloadserver_url)
}





