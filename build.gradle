// For deployment on server
// ORG_GRADLE_PROJECT_dl_host - download host
// ORG_GRADLE_PROJECT_tag_url - git repo

// ORG_GRADLE_PROJECT_repoactoron - nexus

// Maven central needs
// ORG_GRADLE_PROJECT_repocentral
// ORG_GRADLE_PROJECT_sigKey
// ORG_GRADLE_PROJECT_signingPassword

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
  	classpath 'com.hierynomus:sshj:0.38.0'
  }
}

plugins {
    id 'java-library'
    id 'maven-publish'
    id 'signing'
}

//signing {
//    sign(publishing.publications["mavenJava"])
//}

if(project.hasProperty('repos')) {
    for(String repo: repos.split(",")) {
        // Parse credentials from environment
        def repourl = getVar('repo' + repo, project)
        def repoaccess = parseURLWithCredentials(repourl)
        println 'publishing to: ' + repoaccess.url
        println 'repouser: ' + repoaccess.user
        println 'repopassword: ' + repoaccess.password

        if("central".equals(repo)) {
            // Settings for staging when publishing to central repo
            publishing {
                /*publications {
                    mavenJava(MavenPublication) {
                        from components.java
                    }
                }*/
                repositories {
                    maven {
                        url = uri('https://oss.sonatype.org/service/local/staging/deploy/maven2/')
                        credentials {
                            username = repoaccess.user
                            password = repoaccess.password
                        }
                    }
                }
            }
        } else {
            // Settings for non-staging publications like nexus.actoron.com
            publishing {
                publications {
                    mavenJava(MavenPublication) {
                        from components.java
                    }
                }
                repositories {
                    maven {
                        url = uri(repoaccess.url)
                        credentials {
                            username = repoaccess.user
                            password = repoaccess.password
                        }
                    }
                }
            }
        }
    }
}

// Skip old/unfinished projects in gradle build. these are still included in eclipse
def excludes = ['communication', 'nfproperties']

['clean', 'compileJava', 'assemble', 'build', 'test', 'check', 'wrapper', 'sonarcube'].each { mytask ->
	if(tasks.names.contains(mytask)) {
		//println "Configuring task '"+mytask+"'"
		tasks.named(mytask) {
			gradle.includedBuilds.each { build ->
				if(!excludes.contains(build.name)) {
					dependsOn build.task(':'+mytask)
				}
			}
		}
	}
	else {
		//println "Creating task '"+mytask+"'"
		project.tasks.create([name: mytask]) {	
			gradle.includedBuilds.each { build ->
				if(!excludes.contains(build.name)) {
					dependsOn build.task(':'+mytask)
				}
			}
		}
	}
}

def getVar(String key, Project p) {
    String value = System.getenv(key)
    print "key: $key, project: $p, value: $value \n"
    if (!value || value.isEmpty()) {
        if (project.hasProperty(key)) {
            value = project[key]
        } else {
            value = null
        }
    }
    return value
}

def createEmptyDirOnSSH(net.schmizz.sshj.SSHClient ssh, String dir) {
	def session = ssh.startSession();
	def cmd = session.exec("ls " + dir);
	waitForSSHCmd(cmd);
	cmd.close();
	
	if (cmd.getExitStatus() == 0) {
		// Old deployment exist, remove...
		session = ssh.startSession();
		cmd = session.exec("rm -rf " + dir);
		waitForSSHCmd(cmd);
		cmd.close();
	}
	
	session = ssh.startSession();
	cmd = session.exec("mkdir " + dir);
	waitForSSHCmd(cmd);
	cmd.close();
}

def waitForSSHCmd(cmd) {
	// BufferedReader reader = new BufferedReader(new InputStreamReader(cmd.getInputStream()));
	// reader.lines().collect(java.util.stream.Collectors.joining("\n"));
	def is = cmd.getInputStream();
	def data = new byte[4096];
	int cnt;
	while((cnt = is.read(data, 0, data.length))!=-1) {
		//System.out.write(data, 0, cnt);
		//System.out.flush();
	}
}

// Parse a URI into its components.
// see, e.g., https://tools.ietf.org/html/draft-ietf-secsh-scp-sftp-ssh-uri-04
// Examples:
// https://myserver.com/path -> {host: "myserver.com", port: -1, user: "", password: "", fingerprint: "", url: "https://myserver.com/path"}
// https://a@myserver.com/path -> {host: "myserver.com", port: -1, user: "a", password: "", fingerprint: "", url: "https://myserver.com/path"}
// ssh://a:b;fingerprint=SHA256-ABC@myserver.com:22000  -> {host: "myserver.com", port: 22000, user: "a", password: "b", fingerprint: "SHA256:ABC", url: "ssh://myserver.com:22000"}
def parseURLWithCredentials(urlstring) {
	//println "urlstring: "+urlstring
	
	def ret = [:];
	def uri	= new URI(urlstring)
	ret.host = uri.host;
	ret.port = uri.port
    ret.user = ''
    ret.password = ''
    ret.fingerprint = ''
    def String userinfo = uri.userInfo
    if(userinfo!=null)
    {
		def String[] split = userinfo.split(":|;")
		//println 'userinfo: ' + split
        ret.user = split.length>0 ? split[0] : ''
        ret.password = split.length>1 ? split[1] : ''
        
        for(int i=2; i<split.length; i++)
        {
        	if(split[i].startsWith('fingerprint='))
        	{
        		// Fingerprint info according to https://tools.ietf.org/html/draft-ietf-secsh-scp-sftp-ssh-uri-04
        		ret.fingerprint	= split[i].substring('fingerprint='.length()).replace('-', ':')
        		//println 'fingerprint: ' + ret.fingerprint
        	}
        }
	}

	// URL without extra info (e.g. no password for security reasons)
	ret.url	= uri.scheme + '://' + uri.host + (uri.port!=-1 ? ':' + uri.port : '') + (uri.rawPath!=null ? uri.rawPath : '') + (uri.rawQuery!=null ? '?' + uri.rawQuery : '') + (uri.rawFragment!=null ? '#' + uri.rawFragment : '')
	//println 'url: ' + ret.url
		
	return ret;
}

task createZip(type: Zip) {
	
	project.ext.version = fetchNextBuildNameFromGitTag()
	project.ext.jadex_build_version = project.ext.version.full
	println "Jadex Build Version " + project.ext.jadex_build_version 

    archiveFileName = 'jadex-v'+project.ext.jadex_build_version+'.zip'
    destinationDirectory = file('deploy')
    includeEmptyDirs = false
    
    from(sourceSets.main.output) {
        gradle.includedBuilds.each { build ->
            from("${build.projectDir}/build/libs") {
                include '**/*.jar'
                into 'lib' 
                eachFile { f -> f.path = "lib/${f.name}" }
                duplicatesStrategy = DuplicatesStrategy.EXCLUDE
            }
        }
    }

    //def classpath = gradle.includedBuilds.collect { build -> build.projectDir.path + "/build/libs/*.jar" }.join(':')
    def scriptContent = '#!/bin/bash\njava -cp "lib/*" jadex.micro.helloworld.HelloWorldAgent'
    def scriptFile = file('startHelloWorld.sh')
    scriptFile.text = scriptContent
    scriptFile.setExecutable(true)
    
    into('') {
        from scriptFile
    }
}

task deployZip() {
	dependsOn createZip
	doLast {
		//if(!gradle.ext.productionmode)
		//	throw new IllegalStateException("Can only deploy zips in production mode.");
		
		if(getVar('dl_host', project)==null)
			throw new RuntimeException("Deploy requires deployment variables set: dl_host, tag_url");
		
		def acc = getDownloadServerAccess();
		
		def dir = "/www/releases/" + project.ext.jadex_build_version;
		//def zipsdir = "" + project.buildDir + File.separator + 'distributions' + File.separator + 'zips';
		def zipsdir = file('deploy').path;

		net.schmizz.sshj.SSHClient ssh = new net.schmizz.sshj.SSHClient();
		ssh.addHostKeyVerifier(acc.fingerprint);
		ssh.connect(acc.host, acc.port);
		try {
			ssh.authPassword(acc.user, acc.password);
			
			createEmptyDirOnSSH(ssh, dir);
			
			def children = new net.schmizz.sshj.xfer.FileSystemFile(zipsdir).getChildren();
			for (def child : children) {
				ssh.newSCPFileTransfer().upload(child, dir + "/");
			}
        } catch (Exception e) {
        	throw new RuntimeException(e); 
        } finally {
            ssh.disconnect();
        }
        
		println "Zip deployed.";
	}
}

def getDownloadServerAccess() {
	def downloadserver_url = getVar('dl_host', project)
    return parseURLWithCredentials(downloadserver_url)
}

// Separated versioning utilities, used by main build.gradle as well as docs/mkdocs-ng
Object fetchNextBuildNameFromGitTag()
{
	// Fetch major.minor version from properties
	//def versionprops = readProperties file: 'src/main/buildutils/jadexversion.properties'
	def versionprops = new Properties()
	//file("src/main/buildutils/jadexversion.properties").withInputStream { versionprops.load(it) }
	file("jadexversion.properties").withInputStream { versionprops.load(it) }

	def version = versionprops.jadexversion_major + "." + versionprops.jadexversion_minor
	//println "version from props is: "+version+ ", " + versionprops
	
	// Fetch patch from gradle command property (e.g. for checkDist rebuild of srcDist)
	def patchstr = gradle.startParameter.getProjectProperties().get('jadexversion_patch');
	if (patchstr != null)
		return createBuildname(version, patchstr, 1, false)
	
//	// If we are rebuilding from unzipped distribution sources, get patch from properties.
//	if(versionprops.containsKey("jadexversion_patch") && versionprops.jadexversion_patch.isInteger())
//		return createBuildname(version, versionprops.jadexversion_patch, 1, false)

	// If we are building in dev mode (i.e. Eclipse), just set patch to 9999 and exit.
	//if (!gradle.ext.productionmode)
	//	return createBuildname(version, '9999-SNAPSHOT', 1, false)
		
	def patch = getLatestPatchVersion(version, versionprops);
	
	//println "patch from git is: "+patch
	
	def branchpatch = 1; // Start branch subnumbers at 1, because jadex-1.2.3-branch-0 is ugly(?)
	def buildname	= null;

	// Fetch latest major.minor.patch[-branchname-branchpatch] tag from git for non-master/stable branches
	
	// todo
	/*if(includeBranchName(env.BRANCH_NAME)) {
		def suffix = getLatestTagSuffix(version+"."+patch+"-"+env.BRANCH_NAME+"-")
		if(suffix!=null)
			branchpatch = suffix as Integer;
	}*/
	
	// Create the build name based on version path and branch info.		
	buildname = createBuildname(version, patch, branchpatch, false)
	
	// If tag for buildname exists, but is not head -> there are commits since last tag -> increment (branch) patch number.
	if(getLatestTagSuffix(buildname.full)!=null && !isHead(buildname.full))
	{
		//if(includeBranchName(env.BRANCH_NAME))
		//	branchpatch++
		//else
			patch++
		buildname = createBuildname(version, patch, branchpatch, true)
	}
	println 'Working on Jadex Version ' + buildname;
	return buildname!=null ? buildname : createBuildname(version, patch, branchpatch, false);
}

// Check if a branch name should be included in version number.
boolean includeBranchName(branch)
{
	return !"master".equals(branch) && !"stable".equals(branch);
}

// Create the build name object.
Object createBuildname(version, patch, branchpatch, isnew)
{
	def buildname = new HashMap() {
		public String toString()
		{
			return "" + this.major + "." + this.minor + "." + this.patch;
		}
	};
	
	// Fetch timestamp from gradle command property (e.g. for checkDist rebuild of srcDist)
	buildname.timestamp = gradle.startParameter.getProjectProperties().get('jadexversion_timestamp');
	if (buildname.timestamp == null)
	{
		// Generate new timestamp (i.e. build time)
		buildname.timestamp	= (long) ((new Date()).getTime() / 1000) // Divide by 1000 to make UNIX time
	}
	
	//def buildname = [:]
	//buildname.suffix = patch + (includeBranchName(env.BRANCH_NAME) ? "-"+env.BRANCH_NAME+"-"+branchpatch : "")
	def splitversion = version.split("\\.");
	buildname.major = Integer.valueOf(splitversion[0]);
	buildname.minor = Integer.valueOf(splitversion[1]);
	buildname.patch = patch;
	buildname.suffix = patch;
	buildname.full = version + "." +buildname.suffix
	buildname.isnew	= isnew;	// isnew -> no tag for this version exists, yet -> enable updateTag task 
	return buildname;
}

// Fetch all tags matching the given major.minor version and 
// return the latest patch version.
// @return The found patch version or 0 if not found.
int getLatestPatchVersion(version, versionprops)
{
	def	patch = 0
	//def status = sh (returnStatus: true,
	//	script: "git log --tags=\"${version}.*\" --no-walk --format=%D >tags.txt")
	
	def git = "git log --tags=${version}.* --no-walk --format=%D";
	//println "git command: "+git
	
	def p1 = git.execute()
	p1.waitFor()
	//println p1.errorStream.text
	
	def status = p1.exitValue()
	def tags = p1.text.split("\\n")
	
	//println "tags are: "+ tags 
	
	if(status==0)
	{
		for(String tag: tags)
		{
			println 'checking tag> ' + tag;
			if(tag.startsWith("tag: "+version+"."))
			{
				tag	= tag.substring(("tag: "+version+".").length())
				if(tag.indexOf("-")!=-1)	// Strip version branch names in tag
					tag	= tag.substring(0, tag.indexOf("-"));
				if(tag.indexOf(",")!=-1)	// Strip git branch names after tag
					tag	= tag.substring(0, tag.indexOf(","));
				
				if(tag.matches("\\d+"))	// Skip tags not conforming to <major>.<minor>.<patch> or <major>.<minor>.<patch>-<branch>-<branchpatch>
				{
				 	patch = Math.max(patch, tag as Integer)
				}
				else
				{
					println "ignored "+tag
				}
			}
		}
	}
	return patch
}

// Fetch the latest tag matching the given prefix and return the suffix.
// @return The suffix or null, when no matching tag is found.
String getLatestTagSuffix(prefix)
{
	//def status = sh (returnStatus: true,
	//	script: "git describe --match \"${prefix}*\" --abbrev=0 > tag.txt")
	//git log --tags="4.0.*" --no-walk --format=%D >tags.txt
	
	//if (project.ext.productionmode)
	//{
		def cmd = "git describe --match ${prefix} --abbrev=0";
		def p1 = cmd.execute();
		p1.waitFor()
		
		def status = p1.exitValue()
		return status==0? p1.text.trim().substring(prefix.length()): null;
	//}
	
}

// Check if a tag points to HEAD.
boolean	isHead(tag)
{
	println "Checking if "+ tag +" points to HEAD"
	//def status = sh (returnStatus: true,
	//	script: "git tag --points-at HEAD > tags.txt")
	
	def p1 = "git tag --points-at HEAD.execute()".execute()
	p1.waitFor()
	
	def status = p1.exitValue()
	def tags = p1.text
		
	if(status==0)
		return java.util.Arrays.asList(tags.trim().split("\\n")).contains(tag)
	return false;
}

ext 
{
	fetchNextBuildNameFromGitTag = this.&fetchNextBuildNameFromGitTag
}

// -------------------------------------
// ---------- POM contents -------------
// -------------------------------------

def common() {
	return {
        scm {
            url 'https://github.com/actoron/jadex.git'
        }

        url 'https://www.activecomponents.org'

        // beware: organization needs '=' assignment:
        // https://issues.gradle.org/browse/GRADLE-2719
        developers {
            developer {
                id 'alex'
                name 'Alexander Pokahr'
                email 'pokahr@gmx.net'
                //                url 'http://vsis-www.informatik.uni-hamburg.de/members/info.php/84'
                //                organization 'University of Hamburg'
                //                organizationUrl 'http://vsis-www.informatik.uni-hamburg.de/'
                organization 'Actoron GmbH'
                organizationUrl 'https://actoron.com/'
            }
            developer {
                id 'lars'
                name 'Lars Braubach'
                email 'braubach@gmx.net'
                //                url 'http://vsis-www.informatik.uni-hamburg.de/members/info.php/80'
                //                organization 'University of Hamburg'
                //                organizationUrl 'http://vsis-www.informatik.uni-hamburg.de/'
                organization 'Actoron GmbH'
                organizationUrl 'https://actoron.com/'
            }
            developer {
                id 'kai'
                name 'Kai Jander'
                email 'kai.jander@googlemail.com'
                //                url 'http://vsis-www.informatik.uni-hamburg.de/members/info.php/974'
                //                organization 'University of Hamburg'
                //                organizationUrl 'http://vsis-www.informatik.uni-hamburg.de/'
                organization 'Actoron GmbH'
                organizationUrl 'https://actoron.com/'
            }
            developer {
                id 'julian'
                name 'Julian Kalinowski'
                email 'kalinowski@informatik.uni-hamburg.de'
                //                url 'http://vsis-www.informatik.uni-hamburg.de/members/info.php/974'
                //                organization 'Actoron GmbH'
                //                organizationUrl 'https://actoron.com/'
                organization 'University of Hamburg'
                organizationUrl 'http://vsis-www.informatik.uni-hamburg.de/'
            }
        }

    }
}

def commercial() {
	return {
        licenses {
            license {
                name 'Actoron GmbH Commercial Licence'
            }
        }
    }
}

def gpl() {
	return {
		licenses {
			license {
				name 'GPL-3.0'
				url 'https://gnu.org/licenses/gpl-3.0'
				distribution 'repo'
			}
		}
	}
}


// -------------------------------------
// ------------ PUBLISH ----------------
// -------------------------------------

def canSign = project.hasProperty('signing.secretKeyRingFile') || getVar("signingKey", project)!=null

//println getVar("signingKey", project)

//// Selects the projects to publish, add a better heuristic here if available
//def includedproject = getProjectDepth(project) > 1

def configurePom(pom) {
    pom.withXml {
        def root = asNode()
        root.appendNode('description', project.description)
        root.appendNode('name', project.name)
        if (!root.get('packaging').isEmpty()) 
        {
            root.remove(root.get('packaging'))
        }
        root.children().last() + common()
        root.children().last() + gpl()
    }
}

// Sign the (single) output of another task.
def createSignTask(origtask, classi, exten) {
    def signtask = project.tasks.create('sign' + origtask.name.capitalize(), Sign) {
    	outputs.cacheIf { true }
   		dependsOn origtask
   		//doLast {
		//	println "signtask: " + origtask+", "+classi+", "+exten
   		//}
    }
        
    signtask.sign(classi, origtask.outputs.files.singleFile)
    
    // Change name of signature file to not include version number -> allows caching across version as long as jar contents haven't changed
    if(origtask instanceof AbstractArchiveTask) {
	    signtask.signatures.each { sig ->
	    	sig.name	= origtask.archiveBaseName.get() + (classi!=null ? '-' + classi : '') + '.' + exten + sig.name.substring(sig.name.lastIndexOf('.'))
	    }
	}
	
	signtask.signatureFiles.each { sigfile ->
		publishing.publications.mavenJava.artifact(sigfile)
		{
			builtBy signtask
			classifier classi
			extension exten + sigfile.name.substring(sigfile.name.lastIndexOf('.'))
		}
	}
	// Signatory getting created for each task takes a long time -> reuse one signatory for all tasks
	project.afterEvaluate {
		def signat	= rootProject.ext.signatory
		if(signat==null) {
			signat	= signtask.signatory
			rootProject.ext.signatory	= signat
		} else {
			signtask.setSignatory(signat)
		}
	}
}

if(canSign) {
	signing {
		// for signing with keys by environment variables https://docs.gradle.org/current/userguide/signing_plugin.html
		//def signingKey1 = findProperty("signingKey")
		//def signingPassword1 = findProperty("signingPassword")
		//println("sign key1: "+signingKey1)
		
		
		def signingKey = getVar("signingKey", project)
		def signingPassword = getVar("signingPassword", project)
		//println("sign key2: "+signingKey)
		useInMemoryPgpKeys(signingKey, signingPassword)

		// Sign archives and pom in separate tasks as archive signing can be cached while pom signing cannot, when jadex version changes.
		//sign publishing.publications.mavenJava
	}
}

def singularize(name) {
	if (name.endsWith('s') && !project.ext.keepplural.contains(name))
		name = name.substring(0, name.length() - 1)
	return name;
}

def getArtifactName(project) {
	def ret = 'jadex'
    def pathcomps = project.getPath().split(':')
    for (int i = 1; i < pathcomps.length; ++i) {
    	def comp = pathcomps[i]
    	if (i == 1)
    		comp = singularize(comp)
    	ret += '-' + comp
    }
    return ret
}

publishing {
    publications {
        mavenJava(MavenPublication) {
         println "Anzahl der Komponenten von components.java: ${components.java.each{ component -> println 'hi'}}"
        
            if (canSign) {
                // Sign archives and pom in separate tasks as archive signing can be cached while pom signing cannot, when jadex version changes.
                createSignTask(generatePomFileForMavenJavaPublication, null, 'pom')
                createSignTask(generateMetadataFileForMavenJavaPublication, null, 'module')
            }

            from components.java
            
            if (canSign) {
                createSignTask(jar, null, 'jar')

                // Add xyz-sources.jar and xyz-javadoc.jar for Maven Central
                project.tasks.withType(Jar) { task ->
                    if (task.name.equals('sourcesJar') || task.name.equals('javadocJar')) {
                        def artifact = artifact(task)
                        createSignTask(task, artifact.classifier, artifact.extension)
                    }
                }
            } else {
                println "Cannot sign"
            }

            groupId 'org.activecomponents.jadex'
            artifactId getArtifactName(project)
            version project.version
            configurePom(pom)
        }
    }
}
