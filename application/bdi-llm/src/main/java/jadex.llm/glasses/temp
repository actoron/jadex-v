//            public String generatePrompt(List<Class<?>> classes, List<Object> objects) {
//                List<String> combinedInfo = new ArrayList<>();
//
//                for (Class<?> cls : classes) {
//                    combinedInfo.add(ClassReader.getClassStructure(String.valueOf(cls)));
//                }
//
//                for (Object obj : objects) {
//                    combinedInfo.add(obj.toString());
//                }
//
//                String infoString = String.join(", ", combinedInfo);
//                String plan = sendRequest(infoString);
//
//                plan = "package aibdi;\nimport java.util.List;\nimport java.util.Comparator;\nimport java.util.Iterator;\n" + plan;
//
//                System.out.println("executeGeneratedPlan: " + plan);
//
//                if (!plan.isEmpty()) {
//                    String className = "bdi-llm.PlanStep";
//                    String methodName = "doPlanStep";
//                    Class<?>[] parameterTypes = new Class<?>[]{List.class};
//                    Object[] args = objects.toArray();
//
//                    byte[] byteCode = CodeCompiler.compile(className, plan);
//                    if (byteCode != null) {
//                        Object planInstance = CodeCompiler.execute(className, byteCode, methodName, parameterTypes, args);
//                        if (planInstance != null) {
//                            System.out.println("Plan instance created");
//                        } else {
//                            System.out.println("Plan instance could not be created");
//                        }
//                    } else {
//                        System.out.println("Compilation failed");
//                    }
//                } else {
//                    System.out.println("Generated code is empty");
//                }
//                return plan;
//            }
//
//            public String sendRequest(String infoString) {
//                Gson gson = new Gson();
//
//                String prompt = "You are a sophisticated code generator skilled in Java. Don't explain the code, just generate the code block itself. Create a Java class named PlanStep that is designed to work within a Jadex agent environment. The class should contain a method named doPlanStep, which takes a list of Glasses objects and a GlassesSortingGoal object as parameters. The 'doPlanStep' method should implement logic to sort the glassesList based on the sortingPreference defined in the GlassesSortingGoal object. After sorting the list, the method should print the sorted list and return it. Use Java's Comparator interface or lambda expressions for sorting. Assume that the Glasses, GlassesSortingGoal classes, and the SortBy enum are already defined in the project. Include the complete method implementation for sorting and returning the glassesList within the 'doPlanStep' method. The method should return the sorted list of Glasses. The class should not include a main method or the @Plan annotation. " + "\n" + "The project has the following class structures: \n" + infoString;
//                String json = gson.toJson(new LLMRequest("gpt-3.5-turbo", new Message("user", prompt)));
//
//                System.out.println("Sending JSON: " + json);
//
//                HttpRequest request = HttpRequest.newBuilder()
//                        .uri(URI.create(url))
//                        .header("Content-Type", "application/json")
//                        .header("Authorization", "Bearer " + apiKey)
//                        .POST(HttpRequest.BodyPublishers.ofString(json))
//                        .build();
//
//                try {
//                    HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
//                    System.out.println("Response status code: " + response.statusCode());
//                    System.out.println("Response body: " + response.body());
//
//                    if (response.statusCode() == 200) {
//                        return extractGeneratedCode(response.body());
//                    } else {
//                        throw new Exception("LLM returned status code " + response.statusCode());
//                    }
//                } catch (Exception e) {
//                    e.printStackTrace();
//                    return null;
//                }
//            }
//
//            public String extractGeneratedCode(String responseBody) {
//                System.out.println("--> Extracting code from response");
//                int startIdx = -1;
//                for (int i = 0, count = 0; i < responseBody.length(); i++) {
//                    if (responseBody.charAt(i) == '{') {
//                        count++;
//                        if (count == 4) {
//                            startIdx = i;
//                            break;
//                        }
//                    }
//                }
//
//                if (startIdx != -1) {
//                    int bracketCount = 1;
//                    int currentIdx = startIdx + 1;
//
//                    while (currentIdx < responseBody.length() && bracketCount > 0) {
//                        char currentChar = responseBody.charAt(currentIdx);
//                        if (currentChar == '{') {
//                            bracketCount++;
//                        } else if (currentChar == '}') {
//                            bracketCount--;
//                        }
//                        currentIdx++;
//                    }
//
//                    if (bracketCount == 0) {
//                        String generatedCode = responseBody.substring(startIdx, currentIdx).trim();
//                        generatedCode = generatedCode.replace("\\n", "\n").replace("\\t", "\t").replace("\\\"", "\"");
//                        System.out.println("-->Trimmed code version:\n" + generatedCode);
//                        return generatedCode;
//                    }
//                }
//                System.out.println("No valid codeblock found");
//                return "";
//            }
//
//            class LLMRequest {
//                String model;
//                Message[] messages;
//
//                LLMRequest(String model, Message... messages) {
//                    this.model = model;
//                    this.messages = messages;
//                }
//            }
//
//            class Message {
//                String role;
//                String content;
//
//                Message(String role, String content) {
//                    this.role = role;
//                    this.content = content;
//                }
//            }
//        }


//    private static class ClassReader
//    {
//        private Map<String, String> classStructure;
//        private BDIModelLoader loader;
//
//        public ClassReader()
//        {
//            this.classStructure = new HashMap<>();
//            this.loader = new BDIModelLoader();
//
//        }
//
//        void readClassStructure(Class<?> clazz)
//        {
//            try
//            {
//                SClassReader.ClassInfo ci = SClassReader.getClassInfo(clazz.getName(), clazz.getClassLoader(), true, true);
//
//                String className = ci.getClassName();
//                String superClass = ci.getSuperClassName();
//                List<SClassReader.FieldInfo> fields = ci.getFieldInfos();
//                List<SClassReader.MethodInfo> methods = ci.getMethodInfos();
//
//                //System.out.println("Class: " + className);
//                //System.out.println("Superclass: " + superClass);
//
//                StringBuilder classInfo = new StringBuilder();
//                classInfo.append("Class: ").append(className).append("\n");
//                classInfo.append("Superclass: ").append(superClass).append("\n");
//
//                classInfo.append("Fields:").append("\n");
//                for (SClassReader.FieldInfo fi : fields)
//                {
//                    classInfo.append("\tName: ").append(fi.getFieldName()).append(" -Type: ").append(fi.getFieldDescriptor()).append("\n");
//                }
//
//                classInfo.append("Methods:").append("\n");
//                for (SClassReader.MethodInfo mi : methods)
//                {
//                    classInfo.append("\tName: ").append(mi.getMethodName()).append(" -Type: ").append(mi.getMethodDescriptor()).append("\n");
//                }
//                /*String classStructure = classInfo.toString();
//                classStructure.put(className, classStructure);
//                System.out.println("Class structure added for" + className);*/
//
//                System.out.println("Fields:");
//                for (SClassReader.FieldInfo fi : fields)
//                {
//                    System.out.println("\tName: " + fi.getFieldName() + " -Type: " + fi.getFieldDescriptor());
//                }
//                System.out.println("Methods:");
//                for (SClassReader.MethodInfo mi : methods)
//                {
//                    System.out.println("\tName: " + mi.getMethodName() + " -Type: " + mi.getMethodDescriptor());
//                }
//
//                classStructure.put(className, ci.toString());
//
//            } catch (Exception e)
//            {
//                e.printStackTrace();
//            }
//        }
//
//        public static String getClassStructure(String className)
//        {
//            System.out.println("test" + className);
//            String structure = classStructure.get(className);
//            System.out.println("---->Class structure: " +className + ": " + structure);
//            return structure;
//        }
//    }

        // Initialize LLM feature
        System.out.println("A: Feature initialization started");
        try
        {
            ILlmFeature llmFeature = agent.getFeature(ILlmFeature.class);

            if (llmFeature != null)
            {
                System.out.println("A: LLM Feature found and initializing");

            } else
            {
                System.out.println("A: Nope, Feature not found");
            }
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        agent.getFeature(IBDIAgentFeature.class).dispatchTopLevelGoal(new SortGlassesListGoal()).get();
        System.out.println("A: GlassesAgent finished");

        // Generate glasses list + set sorting goal
        glassesList = Glasses.generateRandomGlassesList();
        sortingGoal = new GlassesSortingGoal(characteristic);


            @Belief
            private List<Glasses> glassesList = new ArrayList<>();

            @Belief
            private SortBy characteristic = SortBy.SHAPE;

            public enum SortBy
            {
                SHAPE, MATERIAL, COLOUR, BRAND, MODEL
            }

            private GlassesSortingGoal sortingGoal;

            public class GlassesSortingGoal
            {
                private SortBy sortBy;

                public GlassesSortingGoal(SortBy sortBy) {
                    this.sortBy = sortBy;
                }

                public SortBy getSortBy() {
                    return sortBy;
                }
            }

            @Goal
            class SortGlassesListGoal
            {
                @GoalResult
                public List<Glasses> getSortedGlassesList() {
                    return glassesList;
                }
            }

            @Plan(trigger = @Trigger(goals = SortGlassesListGoal.class))
            public void executeGeneratedPlan(IPlan context)
            {
        //        System.out.println("A: executeGeneratedPlan is called");
        //        if (llmFeature == null)
        //        {
        //            System.out.println("No LLM feature found");
        //            return;
        //        }
        //
        //        List<Glasses> glassesList = getGlassesList();
        //        if (glassesList == null)
        //        {
        //            System.out.println("A: GlassesList is empty");
        //            return;
        //        }
        //
        //        try
        //        {
        //            System.out.println("A: Execute plan step: " + glassesList.size() + " glasses");
        //            llmFeature.generatePlanStep(new SortGlassesListGoal(), context, glassesList);
        //        }
        //        catch (Exception e)
        //        {
        //            System.out.println("Failed to generate plan step: " + e.getMessage());
        //        }
            }
        //
        //    public List<Glasses> getGlassesList()
        //    {
        //        if (glassesList == null)
        //        {
        //            glassesList = Glasses.generateRandomGlassesList();
        //        }
        //        return null;
        //    }

          private String extractCode(String responseBody)
            {
                System.out.println("F: Extracting code from response");
                int startIdx = -1;
                for (int i = 0, count = 0; i < responseBody.length(); i++) {
                    if (responseBody.charAt(i) == '{') {
                        count++;
                        if (count == 4) {
                            startIdx = i;
                            break;
                        }
                    }
                }
                if (startIdx != -1) {
                    int bracketCount = 1;
                    int currentIdx = startIdx + 1;

                    while (currentIdx < responseBody.length() && bracketCount > 0) {
                        char currentChar = responseBody.charAt(currentIdx);
                        if (currentChar == '{') {
                            bracketCount++;
                        } else if (currentChar == '}') {
                            bracketCount--;
                        }
                        currentIdx++;
                    }
                    if (bracketCount == 0) {
                        String generatedCode = responseBody.substring(startIdx, currentIdx).trim();
                        generatedCode = generatedCode.replace("\\n", "\n")
                                .replace("\\t", "\t").replace("\\\"", "\"");
                        System.out.println("F: Trimmed code version:\n" + generatedCode);
                        return generatedCode;
                    }
                }
                System.out.println("F: No valid codeblock found");
                return "";
            }